"""
eCFR data parser.

Converts raw eCFR API responses to normalized DOC format.
"""

import json
import re
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime
from uuid import uuid4

from ..schemas import DOC, DocType, Jurisdiction


class eCFRParser:
    """Parses eCFR API responses into normalized DOC format."""

    def __init__(self):
        self.authority_rank = 0.9  # High authority for federal regulations

    def parse_section(self, raw_data: Dict[str, Any]) -> Optional[DOC]:
        """
        Parse a single eCFR section into DOC format.

        Args:
            raw_data: Raw eCFR API response data

        Returns:
            Normalized DOC object or None if parsing failed
        """
        try:
            metadata = raw_data.get('_wyngai_metadata', {})
            section_path = metadata.get('section_path', '')

            # Extract section information
            title_match = re.search(r'title-(\d+)', section_path)
            part_match = re.search(r'part-(\d+)', section_path)
            section_match = re.search(r'section-(\d+\.\d+)', section_path)

            title_num = title_match.group(1) if title_match else "Unknown"
            part_num = part_match.group(1) if part_match else "Unknown"
            section_num = section_match.group(1) if section_match else "Unknown"

            # Build citation
            citation = f"{title_num} CFR {section_num}" if section_num != "Unknown" else f"{title_num} CFR Part {part_num}"

            # Extract content
            content = self._extract_content(raw_data)

            # Generate title
            title = self._generate_title(raw_data, citation)

            # Create DOC
            doc = DOC(
                doc_id=uuid4(),
                source_id=f"ecfr_{section_path}",
                category="Federal Regulations & Rulemaking",
                title=title,
                doc_type=DocType.REGULATION,
                jurisdiction=Jurisdiction.FEDERAL,
                citation=citation,
                effective_date=self._parse_effective_date(raw_data),
                published_date=None,  # eCFR doesn't provide original publish date
                revised_date=None,    # Would need additional API calls
                version=datetime.utcnow().strftime("%Y%m%d"),  # Use fetch date as version
                url=metadata.get('api_url', ''),
                license="Public Domain",
                text=content,
                checksum_sha256="",  # Will be auto-generated by pydantic validator
                retrieval_priority=self.authority_rank,
                tags=self._extract_tags(content, citation),
                metadata={
                    'title_number': title_num,
                    'part_number': part_num,
                    'section_number': section_num,
                    'section_path': section_path,
                    'raw_structure': self._extract_structure_info(raw_data)
                }
            )

            return doc

        except Exception as e:
            print(f"Error parsing eCFR section: {e}")
            return None

    def _extract_content(self, raw_data: Dict[str, Any]) -> str:
        """Extract readable text content from eCFR response."""
        content_parts = []

        # Try different content fields in eCFR response
        if 'full_text' in raw_data:
            content_parts.append(raw_data['full_text'])
        elif 'content' in raw_data:
            content_parts.append(str(raw_data['content']))
        elif 'structure' in raw_data:
            # Parse structured content
            content_parts.append(self._parse_structure(raw_data['structure']))

        # Add any additional text fields
        if 'title' in raw_data and raw_data['title']:
            content_parts.insert(0, f"Title: {raw_data['title']}")

        if 'abstract' in raw_data and raw_data['abstract']:
            content_parts.append(f"Abstract: {raw_data['abstract']}")

        content = "\n\n".join(content_parts) if content_parts else json.dumps(raw_data, indent=2)

        # Clean up content
        content = self._clean_text(content)
        return content

    def _parse_structure(self, structure: Any) -> str:
        """Parse eCFR structured content recursively."""
        if isinstance(structure, str):
            return structure
        elif isinstance(structure, dict):
            parts = []
            if 'label' in structure:
                parts.append(f"[{structure['label']}]")
            if 'text' in structure:
                parts.append(structure['text'])
            if 'children' in structure:
                for child in structure['children']:
                    parts.append(self._parse_structure(child))
            return "\n".join(parts)
        elif isinstance(structure, list):
            return "\n".join(self._parse_structure(item) for item in structure)
        else:
            return str(structure)

    def _clean_text(self, text: str) -> str:
        """Clean and normalize text content."""
        # Remove excessive whitespace
        text = re.sub(r'\n\s*\n\s*\n', '\n\n', text)
        text = re.sub(r'[ \t]+', ' ', text)

        # Remove HTML tags if present
        text = re.sub(r'<[^>]+>', '', text)

        # Clean up common formatting issues
        text = text.replace('\xa0', ' ')  # Non-breaking space
        text = text.strip()

        return text

    def _generate_title(self, raw_data: Dict[str, Any], citation: str) -> str:
        """Generate a descriptive title for the document."""
        if 'title' in raw_data and raw_data['title']:
            return f"{citation} - {raw_data['title']}"
        elif 'label' in raw_data and raw_data['label']:
            return f"{citation} - {raw_data['label']}"
        else:
            return f"{citation} - Federal Regulation"

    def _parse_effective_date(self, raw_data: Dict[str, Any]) -> Optional[datetime]:
        """Extract effective date if available."""
        # eCFR API may not always provide effective dates
        # This would need to be enhanced based on actual API response structure
        if 'effective_date' in raw_data:
            try:
                return datetime.fromisoformat(raw_data['effective_date'])
            except (ValueError, TypeError):
                pass
        return None

    def _extract_tags(self, content: str, citation: str) -> List[str]:
        """Extract relevant tags from content."""
        tags = []

        # Add citation-based tags
        if "ERISA" in citation or "erisa" in content.lower():
            tags.append("ERISA")
        if "HIPAA" in citation or "hipaa" in content.lower():
            tags.append("HIPAA")
        if "Medicare" in content:
            tags.append("Medicare")
        if "appeal" in content.lower():
            tags.append("appeals")
        if "claim" in content.lower():
            tags.append("claims")
        if "prior authorization" in content.lower():
            tags.append("prior_authorization")
        if "medical necessity" in content.lower():
            tags.append("medical_necessity")

        # Add CFR title-based tags
        title_match = re.search(r'(\d+) CFR', citation)
        if title_match:
            title_num = title_match.group(1)
            if title_num == "29":
                tags.append("labor_department")
            elif title_num == "45":
                tags.append("hhs")
            elif title_num == "42":
                tags.append("cms")
            elif title_num == "26":
                tags.append("treasury")

        return list(set(tags))  # Remove duplicates

    def _extract_structure_info(self, raw_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract structural information for metadata."""
        structure_info = {}

        if 'structure' in raw_data:
            structure_info['has_structure'] = True
            structure_info['structure_type'] = type(raw_data['structure']).__name__
        else:
            structure_info['has_structure'] = False

        if 'children' in raw_data:
            structure_info['has_children'] = True
            structure_info['children_count'] = len(raw_data.get('children', []))
        else:
            structure_info['has_children'] = False

        return structure_info

    def parse_file(self, file_path: Path) -> Optional[DOC]:
        """
        Parse eCFR data from a JSON file.

        Args:
            file_path: Path to JSON file with eCFR data

        Returns:
            Normalized DOC object or None if parsing failed
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                raw_data = json.load(f)
            return self.parse_section(raw_data)
        except Exception as e:
            print(f"Error parsing file {file_path}: {e}")
            return None

    def parse_directory(self, input_dir: Path) -> List[DOC]:
        """
        Parse all eCFR JSON files in a directory.

        Args:
            input_dir: Directory containing eCFR JSON files

        Returns:
            List of normalized DOC objects
        """
        docs = []
        json_files = list(input_dir.glob("*.json"))

        print(f"Parsing {len(json_files)} eCFR files from {input_dir}")

        for file_path in json_files:
            doc = self.parse_file(file_path)
            if doc:
                docs.append(doc)
                print(f"✓ Parsed {file_path.name}")
            else:
                print(f"✗ Failed to parse {file_path.name}")

        print(f"Successfully parsed {len(docs)}/{len(json_files)} eCFR files")
        return docs